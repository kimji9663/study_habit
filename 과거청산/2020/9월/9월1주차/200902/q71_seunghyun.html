<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>깊이 우선 탐색</title>
    </head>
    <body>
        <script>
            // **깊이 우선 탐색**이란 목표한 노드를 찾기 위해 가장 우선순위가 높은 노드의 자식으로 깊이 들어갔다가 목표 노드가 존재하지 않으면 처음 방문한 노드와 연결된 다른 노드부터 그 자식 노드로 파고드는 검색 방법을 말합니다.

            // 다음과 같이 리스트 형태로 노드들의 연결 관계가 주어진다고 할 때 깊이 우선 탐색으로 이 노드들을 탐색했을 때의 순서를 공백으로 구분하여 출력하세요.

            // **데이터**
            // graph = {'E': ['D', 'A'],
            //         'F': ['D'],
            //         'A': ['E', 'C', 'B'],
            //         'B': ['A'],
            //         'C': ['A'],
            //         'D': ['E','F']}

            // **출력**
            // E D F A C B

            // * 잘 풀지 못해서 답안지보며 하나씩 해석해보는데 답안지도 잘못되어 있었음.
            // * 문제가 되는 부분 수정하고 코드도 간소화함.
            const graph = {
                A: ["E", "C", "B"],
                B: ["A"],
                C: ["A"],
                D: ["E", "F"],
                E: ["D", "A"],
                F: ["D"],
            };

            function dfs(graph, start) {
                let visited = [];
                let stack = [start];
                while (stack.length !== 0) {
                    let n = stack.shift();
                    if (!visited.includes(n)) {
                        visited.push(n);
                        graph[n].filter((x) =>
                            !visited.includes(x) ? stack.push(x) : false
                        );
                    }
                }
                return visited;
            }

            console.log(dfs(graph, "E"));

            // 문제의 답안지
            // const graph = {
            //     A: ["E", "C", "B"],
            //     B: ["A"],
            //     C: ["A"],
            //     D: ["E", "F"],
            //     E: ["D", "A"],
            //     F: ["D"],
            // };

            // function dfs(graph, start) {
            //     let visited = [];
            //     let stack = [start];

            //     while (stack.length !== 0) {
            //         let n = stack.pop();
            //         if (!visited.includes(n)) {
            //             visited.push(n);
            //             let sub = graph[n].filter((x) => !visited.includes(x));
            //             for (let i of sub) {
            //                 stack.push(i);
            //             }
            //         }
            //     }
            //     return visited;
            // }

            // console.log(dfs(graph, "E"));
        </script>
    </body>
</html>
